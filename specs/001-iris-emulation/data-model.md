# Data Model: Instance - IRIS Database Emulation & Remediation

**Phase**: 1 (Design & Contracts)  
**Date**: 2026-02-05  
**Purpose**: Define all entities, their attributes, relationships, and validation rules

## Entity Definitions

### 1. IRISMessage

**Purpose**: Represents a single entry from InterSystems IRIS messages.log file

**Attributes**:
- `timestamp` (str): IRIS format timestamp `MM/DD/YY-HH:MM:SS:mmm` (e.g., "11/14/25-09:45:55:657")
- `process_id` (int): Unix process ID of IRIS daemon (e.g., 50745)
- `severity` (int): Error severity level, enum [0=Info, 1=Warning, 2=Error, 3=Severe]
- `category` (str): IRIS message category (e.g., "Generic.Event", "Database.MountedRW", "WriteDaemon.Started")
- `message_text` (str): Human-readable message content
- `generated_at` (datetime): ISO 8601 timestamp when message was generated by Instance system
- `trace_id` (str): OpenTelemetry format trace ID (128-bit hex string)

**Validation Rules**:
- `timestamp`: Must match regex `^\d{2}/\d{2}/\d{2}-\d{2}:\d{2}:\d{2}:\d{3}$`
- `process_id`: Must be positive integer 1-999999
- `severity`: Must be 0, 1, 2, or 3
- `category`: Must match regex `^[A-Za-z]+(\.[A-Za-z]+)*$` (dot-separated words)
- `message_text`: Non-empty string, max 500 characters
- `trace_id`: Must be 32-character hex string (128 bits)

**State Transitions**: Immutable once created (no state changes)

**Example**:
```python
IRISMessage(
    timestamp="11/14/25-09:45:57:762",
    process_id=50803,
    severity=2,
    category="Generic.Event",
    message_text="Kerberos authentication unavailable: Error opening Kerberos library",
    generated_at="2026-02-05T14:23:45.123456Z",
    trace_id="a1b2c3d4e5f6789012345678901234ab"
)
```

---

### 2. RemediationCommand

**Purpose**: External JSON command instructing Instance to perform remediation actions

**Attributes**:
- `command_id` (UUID): Unique identifier for command tracking
- `error_type` (enum): Category of error being remediated [`config`, `license`, `resource`]
- `severity` (int): Error severity from original IRIS message [0-3]
- `recommended_action` (str): Human-readable description of action to take
- `parameters` (dict[str, Any]): Action-specific parameters (validated per action type)
- `requires_restart` (bool): Whether remediation requires IRIS instance restart
- `execution_order` (list[str]): Ordered list of tool names to execute
- `dry_run` (bool): If true, validate but don't apply changes (default: false)
- `timeout_seconds` (int): Max execution time, default 60, range [10-300]

**Validation Rules**:
- `error_type`: Must be one of ["config", "license", "resource"]
- `recommended_action`: Non-empty string, max 200 characters
- `parameters`: Must conform to schema for error_type (see Tool Parameter Schemas below)
- `execution_order`: Each tool name must exist in ["iris_config", "os_config", "iris_restart"]
- `timeout_seconds`: Must be 10-300 inclusive

**State Transitions**: 
- `pending` → `validating` → `executing` → `completed` | `failed`

**Tool Parameter Schemas**:

**For `error_type="config"` (IRIS Configuration)**:
```python
{
    "cpf_section": str,  # e.g., "config", "startup"
    "parameter": str,    # e.g., "globals", "routines"
    "new_value": str,    # e.g., "512", "256"
    "current_value": str | None  # Optional: expected current value for safety
}
```

**For `error_type="resource"` (OS Configuration)**:
```python
{
    "kernel_param": str,  # e.g., "kernel.shmmax", "kernel.shmall"
    "new_value": int,     # Bytes or count
    "min_value": int | None,  # Optional: minimum safe value
    "max_value": int | None   # Optional: maximum safe value
}
```

**For `error_type="license"`**:
```python
{
    "action": Literal["check_expiry", "validate_key", "report_usage"]
}
```

**Example**:
```python
RemediationCommand(
    command_id=UUID("123e4567-e89b-12d3-a456-426614174000"),
    error_type="config",
    severity=2,
    recommended_action="Increase global buffer size to 512MB",
    parameters={
        "cpf_section": "config",
        "parameter": "globals",
        "new_value": "512",
        "current_value": "256"
    },
    requires_restart=True,
    execution_order=["iris_config", "iris_restart"],
    dry_run=False,
    timeout_seconds=120
)
```

---

### 3. ToolResult

**Purpose**: Outcome of a single tool execution

**Attributes**:
- `tool_name` (str): Name of tool executed (e.g., "iris_config", "os_config", "iris_restart")
- `command_id` (UUID): Links to originating RemediationCommand
- `status` (enum): Execution outcome [`success`, `failure`, `partial`]
- `execution_time_ms` (int): Duration in milliseconds
- `changes_applied` (dict[str, ChangeDetail]): Map of parameter → old/new values
- `error_message` (str | None): Error details if status=failure
- `requires_user_action` (bool): True if manual intervention needed
- `rollback_available` (bool): True if changes can be reverted
- `trace_id` (str): OpenTelemetry trace ID for correlation

**ChangeDetail Sub-Schema**:
```python
class ChangeDetail(BaseModel):
    parameter: str
    old_value: str | int | None
    new_value: str | int
    validated: bool
```

**Validation Rules**:
- `status`: Must be one of ["success", "failure", "partial"]
- `execution_time_ms`: Must be 0-60000 (0-60 seconds)
- `error_message`: Required if status=failure, null otherwise
- `changes_applied`: Empty dict if status=failure

**Example**:
```python
ToolResult(
    tool_name="iris_config",
    command_id=UUID("123e4567-e89b-12d3-a456-426614174000"),
    status="success",
    execution_time_ms=1250,
    changes_applied={
        "globals": ChangeDetail(
            parameter="globals",
            old_value="256",
            new_value="512",
            validated=True
        )
    },
    error_message=None,
    requires_user_action=False,
    rollback_available=True,
    trace_id="a1b2c3d4e5f6789012345678901234ab"
)
```

---

### 4. WorkflowTrace

**Purpose**: End-to-end audit trail for multi-step remediation workflows

**Attributes**:
- `trace_id` (str): OpenTelemetry trace ID linking all steps
- `command_id` (UUID): Originating RemediationCommand
- `initiated_at` (datetime): ISO 8601 timestamp of workflow start
- `command_received` (RemediationCommand): Full command that triggered workflow
- `steps_executed` (list[ToolResult]): Ordered list of tool results
- `overall_status` (enum): Aggregate status [`success`, `failure`, `partial`]
- `completion_time_ms` (int): Total workflow duration
- `failed_at_step` (int | None): Index of first failed step (if any)

**Validation Rules**:
- `overall_status`: "success" only if all steps succeeded, "failure" if any critical step failed
- `completion_time_ms`: Sum of all step execution times + orchestration overhead
- `failed_at_step`: Must be valid index into steps_executed if status=failure

**Status Determination Logic**:
- `success`: All steps in execution_order completed with status=success
- `partial`: At least one step succeeded, one step failed/partial
- `failure`: First step failed or critical failure

**Example**:
```python
WorkflowTrace(
    trace_id="a1b2c3d4e5f6789012345678901234ab",
    command_id=UUID("123e4567-e89b-12d3-a456-426614174000"),
    initiated_at="2026-02-05T14:23:45.000Z",
    command_received=RemediationCommand(...),
    steps_executed=[
        ToolResult(tool_name="iris_config", status="success", ...),
        ToolResult(tool_name="iris_restart", status="success", ...)
    ],
    overall_status="success",
    completion_time_ms=35420,
    failed_at_step=None
)
```

---

### 5. MessageGenerationRequest

**Purpose**: Request to generate IRIS log messages (internal API)

**Attributes**:
- `error_category` (enum): Type of error to generate [`config`, `license`, `resource`]
- `count` (int): Number of messages to generate (default: 1, max: 100)
- `severity_range` (tuple[int, int]): Min and max severity (default: (0, 3))
- `include_timestamps` (bool): Whether to generate timestamps (default: true)
- `output_format` (enum): Format for output [`raw`, `json`]
- `template_name` (str | None): Optional specific error template to use
- `seed` (int | None): Random seed for reproducible generation (testing only)

**Validation Rules**:
- `error_category`: Must be one of ["config", "license", "resource"]
- `count`: Must be 1-100 inclusive
- `severity_range`: Both values 0-3, min <= max
- `output_format`: Must be one of ["raw", "json"]

**Example**:
```python
MessageGenerationRequest(
    error_category="config",
    count=5,
    severity_range=(1, 3),
    include_timestamps=True,
    output_format="json",
    template_name="buffer_size_error",
    seed=42
)
```

---

## Entity Relationships

```
┌─────────────────────────┐
│ MessageGenerationRequest│
└────────────┬────────────┘
             │ generates
             ▼
    ┌─────────────────┐
    │   IRISMessage   │
    └────────┬────────┘
             │ published to external
             │ triggers
             ▼
┌───────────────────────┐
│  RemediationCommand   │◄─────── consumed from external
└──────────┬────────────┘
           │ creates
           ▼
  ┌──────────────────┐
  │  WorkflowTrace   │
  └────────┬─────────┘
           │ contains
           ▼
     ┌────────────┐
     │ ToolResult │ (1 per tool in execution_order)
     └────────────┘
```

**Key Relationships**:
1. **MessageGenerationRequest → IRISMessage** (1:N): One request generates multiple messages
2. **IRISMessage → RemediationCommand** (1:1 or 1:0): A message may trigger a command from external system
3. **RemediationCommand → WorkflowTrace** (1:1): Each command creates one workflow trace
4. **WorkflowTrace → ToolResult** (1:N): Workflow contains multiple tool execution results
5. **Trace ID propagation**: All entities in a workflow share the same `trace_id`

---

## Validation Cross-Checks

### RemediationCommand → Tool Parameter Validation
When `error_type="config"` and `execution_order` includes "iris_config":
- `parameters` must include keys: `cpf_section`, `parameter`, `new_value`
- `cpf_section` must be valid IRIS section: ["config", "startup", "TCP", "SQL"]
- `parameter` must be known CPF parameter for that section

### ToolResult → WorkflowTrace Consistency
- All `ToolResult.command_id` must match `WorkflowTrace.command_id`
- All `ToolResult.trace_id` must match `WorkflowTrace.trace_id`
- Order of `ToolResult` in `WorkflowTrace.steps_executed` must match `RemediationCommand.execution_order`

### IRISMessage Format Validation
After LLM generation, validate:
1. Timestamp format matches regex
2. Process ID is reasonable (1000-99999)
3. Severity is valid (0-3)
4. Category matches known IRIS categories from log_samples/
5. Message text doesn't contain newlines or special characters

---

## Pydantic Implementation Notes

All models use Pydantic v2 with these patterns:

```python
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import Literal
from datetime import datetime
from uuid import UUID

class IRISMessage(BaseModel):
    timestamp: str = Field(..., pattern=r'^\d{2}/\d{2}/\d{2}-\d{2}:\d{2}:\d{2}:\d{3}$')
    process_id: int = Field(..., gt=0, lt=1000000)
    severity: Literal[0, 1, 2, 3]
    category: str = Field(..., pattern=r'^[A-Za-z]+(\.[A-Za-z]+)*$')
    message_text: str = Field(..., min_length=1, max_length=500)
    generated_at: datetime
    trace_id: str = Field(..., pattern=r'^[a-f0-9]{32}$')
    
    @field_validator('category')
    @classmethod
    def validate_category(cls, v: str) -> str:
        # Additional validation against known categories from log_samples/
        known_categories = ["Generic.Event", "Database.MountedRW", ...]
        if v not in known_categories:
            # Log warning but don't fail (allow new categories)
            logger.warning(f"Unknown IRIS category: {v}")
        return v
    
    class Config:
        frozen = True  # Immutable once created
```

---

## Migration Strategy

**Phase 1**: Implement core models (IRISMessage, RemediationCommand, ToolResult)
**Phase 2**: Add WorkflowTrace for orchestration
**Phase 3**: Add MessageGenerationRequest for internal API

Models are versioned in JSON schema with `$schema` field pointing to version.
